# agents/code_generator_agent.py

from state import ForgeState
from core.file_client import FileSystemClient
from core.shell_client import ShellClient
from core.venv_manager import VirtualEnvManager, sanitize_task_name
import os

class CodeGenerationAgent:
    def __init__(self):
        self.fs_client = FileSystemClient()
        self.shell_client = ShellClient()
        self.venv_manager = VirtualEnvManager()

    async def execute_step(self, state: ForgeState) -> dict:
        """Execute the next step in the plan with bounds checking"""
        
        plan = state.get('plan', [])
        current_step = state.get('current_step', 0)
        
        print(f"---CODER AGENT: Current step {current_step}, Plan length: {len(plan)}---")
        
        # ðŸ”§ BOUNDS CHECK: Prevent index out of range
        if not plan:
            print("---CODER AGENT: No plan available---")
            return {"error": "No plan available to execute"}
        
        if current_step >= len(plan):
            print(f"---CODER AGENT: All {len(plan)} steps completed---")
            return {
                "result": f"All {len(plan)} plan steps completed successfully",
                "current_step": current_step,  # Keep current value
                "all_steps_completed": True,
                "error": None  # Clear any error
            }
        
        step = plan[current_step]
        command = step["command"]
        path = step.get("path")
        content = step.get("content")
        libraries = step.get("libraries")
        
        print(f"---CODER AGENT: Executing step {current_step + 1}/{len(plan)}: {command} on path '{path}'---")
        
        try:
            if command == "CREATE_DIR":
                if not path:
                    return {"error": "CREATE_DIR command requires a path"}
                os.makedirs(path, exist_ok=True)
                print(f"âœ… Created directory: {path}")

            elif command == "CREATE_FILE":
                if not path:
                    return {"error": "CREATE_FILE command requires a path"}
                # ðŸ”§ CONSERVATIVE: Write content if it exists, otherwise create empty file
                content_to_write = step.get("content", "# Auto-generated by The Forge\n")
                await self.fs_client.write_file(path, content_to_write)
                print(f"âœ… Created file: {path}")

            elif command == "WRITE_TO_FILE":
                if not path:
                    return {"error": "WRITE_TO_FILE command requires a path"}
                if not content:
                    return {"error": "WRITE_TO_FILE command requires content"}
                await self.fs_client.write_file(path, content)
                print(f"âœ… Wrote content to file: {path}")

            elif command == "INSTALL_LIBRARIES":
                if not libraries or len(libraries) == 0:
                    print("âœ… No libraries to install - skipping step")
                    return {
                        "result": "No libraries to install - step skipped",
                        "current_step": current_step + 1,
                        "error": None
                    }
                
                raw_task_name = state.get("task", "default_task")
                env_path = self.venv_manager.create_env(raw_task_name)

                for lib in libraries:
                    print(f"Installing library: {lib}")
                    self.venv_manager.install_package(env_path, lib, raw_task_name)
                print(f"âœ… Installed {len(libraries)} libraries")

            else:
                return {"error": f"Unknown command: {command}"}

            # ðŸ”§ SAFE INCREMENT: Only increment if step was successful
            next_step = current_step + 1
            return {
                "result": f"Successfully executed {command}",
                "current_step": next_step,
                "error": None  # Clear any previous errors
            }
        
        except Exception as e:
            print(f"ðŸ”¥ CODER AGENT ERROR: {e}")
            
            # ðŸ”§ CONSERVATIVE: Handle FileSystem server errors with fallback
            if "422 Unprocessable Entity" in str(e) or "Client error" in str(e):
                print("ðŸš« FileSystem MCP server error - falling back to local file creation")
                
                # Fallback: Create file locally instead of using MCP server
                try:
                    if command == "CREATE_FILE":
                        content_to_write = step.get("content") or "# Auto-generated by The Forge\n"
                        with open(path, 'w', encoding='utf-8') as f:
                            f.write(content_to_write)
                        print(f"âœ… Created file locally (fallback): {path}")
                        
                    elif command == "WRITE_TO_FILE":
                        content_to_write = content or "# Auto-generated by The Forge\n"
                        with open(path, 'w', encoding='utf-8') as f:
                            f.write(content_to_write)
                        print(f"âœ… Wrote file locally (fallback): {path}")
                    
                    return {
                        "result": f"Successfully executed {command} (local fallback)",
                        "current_step": current_step + 1,
                        "error": None  # Continue workflow
                    }
                except Exception as fallback_error:
                    return {
                        "error": f"Both MCP server and local fallback failed: {fallback_error}",
                        "current_step": current_step
                    }
            
            # Handle pip install failures
            if "returned non-zero exit status 1" in str(e) and "pip" in str(e) and "INSTALL_LIBRARIES" in command:
                print("ðŸš« Pip install failed - skipping library installation and continuing")
                return {
                    "result": "Library installation skipped due to error",
                    "current_step": current_step + 1,
                    "error": None
                }
            
            return {
                "error": f"Failed to execute {command}: {str(e)}",
                "current_step": current_step
            }